# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19GB5T9MN4sRQ6E7mYr85j4szcTCvfK17
"""

pip install pyzbar Pillow

!apt-get install -y libzbar0

!pip install pyzbar Pillow

!pip install qrcode[pil]

myurl = "https://www.flipkart.com"

import qrcode
from PIL import Image

# Example data to encode in the QR code
data = myurl
# Output file name

filename = "site_inversed.png"

# Generate the QR code image
img = qrcode.make(data)

# Save the image to a file
img.save(filename)  # Save the file in the current directory

# Optionally, display the image
img.show()

import webbrowser
from pyzbar.pyzbar import decode
from PIL import Image

def open_qr_in_browser(image_path):
    # Open the image containing the QR code
    img = Image.open(image_path)

    # Decode the QR code
    decoded_objects = decode(img)

    # Check if any QR code was found
    if not decoded_objects:
        print("No QR code found")
        return

    # Extract the URL from the decoded object
    for obj in decoded_objects:
        url = obj.data.decode('utf-8')
        print(f"Opening URL: {url}")

        # Open the URL in the default web browser automatically
        webbrowser.open(url, new=2)  # `new=2` opens the URL in a new tab, if possible

# Example usage
image_path = "/content/site_inversed.png"  # Replace with the path to your QR code image in Colab
open_qr_in_browser(image_path)

"""imp"""

import numpy as np
import pandas as pd
import math
import re
from urllib.parse import urlparse
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.model_selection import train_test_split
import pickle

# Function to calculate entropy
def calculate_entropy(string):
    """Calculate entropy to capture randomness in a string."""
    probabilities = [float(string.count(c)) / len(string) for c in dict.fromkeys(list(string))]
    return -sum(p * math.log(p, 2) for p in probabilities)

# Function to extract features from a URL
def extract_features(url):
    parsed = urlparse(url)
    hostname = parsed.netloc
    path = parsed.path

    features = {
        'length_url': len(url),
        'length_hostname': len(hostname),
        'ip': int(bool(re.match(r'^\d{1,3}(\.\d{1,3}){3}$', hostname))),
        'nb_dots': url.count('.'),
        'nb_hyphens': url.count('-'),
        'nb_at': url.count('@'),
        'nb_qm': url.count('?'),
        'nb_and': url.count('&'),
        'nb_or': url.count('|'),
        'nb_eq': url.count('='),
        'nb_underscore': url.count('_'),
        'nb_tilde': url.count('~'),
        'nb_percent': url.count('%'),
        'nb_slash': url.count('/'),
        'nb_star': url.count('*'),
        'nb_colon': url.count(':'),
        'nb_comma': url.count(','),
        'nb_semicolumn': url.count(';'),
        'nb_dollar': url.count('$'),
        'nb_space': url.count(' '),
        'nb_www': int('www' in hostname),
        'nb_com': int('.com' in hostname),
        'nb_dslash': url.count('//'),
        'http_in_path': int('http' in path.lower()),
        'https_token': int('https' in url.lower()),
        'ratio_digits_url': sum(c.isdigit() for c in url) / len(url),
        'ratio_digits_host': sum(c.isdigit() for c in hostname) / len(hostname),
        'punycode': int('xn--' in hostname),
        'shortening_service': int(bool(re.search(r'bit\.ly|tinyurl|is\.gd|goo\.gl', url))),
        'path_extension': int(bool(re.search(r'\.\w+$', path))),
        'phish_hints': sum(c in url for c in ['login', 'secure', 'update', 'account', 'free']),
        'entropy_url': calculate_entropy(url),
        'entropy_hostname': calculate_entropy(hostname),
        'suspecious_tld': int(bool(re.search(r'\.(zip|exe|rar|scr|php|xml|bin)$', url)))
    }

    return pd.DataFrame([features])

# Predict for a given URL
def predict_url(url, classifiers, scaler):
    """
    Predict whether the given URL is phishing or legitimate using majority voting.
    """
    input_data = extract_features(url)
    input_scaled = scaler.transform(input_data)

    predictions = []
    for name, clf in classifiers.items():
        pred = clf.predict(input_scaled)
        predictions.append(pred[0])

    majority_vote = int(np.round(np.mean(predictions)))
    # Determine the result based on the value of majority_vote
    print(majority_vote)
    result = "Phishing" if majority_vote == 1 else "Legitimate"

    print(f"\nPrediction Results for URL '{url}':")
    for name, clf in classifiers.items():
        clf_result = "Phishing" if clf.predict(input_scaled)[0] == 1 else "Legitimate"
        print(f"{name}: {clf_result}")
    print(f"\nüéØ Majority Vote Result: {result}")

    return result

# Main execution
if __name__ == "__main__":
    print("Phishing URL Detector")

    # Load classifiers and scaler
    with open('phishing_model.pkl', 'rb') as model_file:
        classifiers = pickle.load(model_file)  # Load all classifiers
        scaler = pickle.load(model_file)      # Load the scaler

    url_to_check = input("Enter a URL to check: ").strip()
    try:
        predict_url(url_to_check, classifiers, scaler)
    except Exception as e:
        print(f"Error: {e}")

import webbrowser

def ask_warning_questions():
    questions = [
        "üìû Have you personally verified the identity of the recipient or organization to ensure they are trusted and legitimate?",
        "‚ùì Is this payment for a valid purpose, and have you confirmed that the recipient's request aligns with the intended transaction?",
        "üåê Please provide the link to the website you are using for this transaction: (e.g., https://example.com). Is this the official website of the recipient or organization?",
        "üîí Have you ensured that the website you are using has a secure connection (look for 'https://' and a padlock symbol in the browser)?",
        "‚ö†Ô∏è Have you reviewed the website or transaction details to ensure there are no signs of fraud, such as unusual domain names, urgent requests, or promises of rewards?"
    ]

    print("\nPlease answer the following questions with 'yes' or 'no':\n")
    for i, question in enumerate(questions, start=1):
        while True:
            print(f"{i}. {question}")

            # Special handling for the website question
            if "Please provide the link to the website" in question:
                website_url = input("\nüåê Kindly provide the link to the official website (e.g., https://example.com): ").strip()
                if website_url.startswith("http://") or website_url.startswith("https://"):
                    open_website = input("Shall I open this link in your browser? (yes/no): ").strip().lower()
                    if open_website == "yes":
                        webbrowser.open(website_url)
                        print("üîó As you wish, I am opening the link in your browser...")
                    print(f"‚úÖ Website URL '{website_url}' noted.")
                else:
                    print("‚ùå The URL must start with 'http://' or 'https://'. Kindly try again.")
                break

            answer = input("Your answer: ").strip().lower()
            if answer in ["yes", "no"]:
                if answer == "no":
                    print("‚ö†Ô∏è Please ensure all questions are answered with 'yes' before proceeding.")
                break
            else:
                print("‚ùå Invalid input. Kindly respond with 'yes' or 'no'.")

    print("\n‚úÖ All questions have been answered. Proceeding with the next steps.")

if result == 'Phishing':
  result = 'Legitimate'
else:
  result = 'Phishing'

print(result)

result = 'Phishing'

def proceed_to_payment():

    # Confirm payment initiation
    print("‚úÖ Proceed to payment.")

    # Simulate the payment process
    print("\nüí≥ Payment processing...\n")

    # Confirm successful payment
    print("‚úÖ Payment successful! The transaction has been completed.")

if __name__ == "__main__":
    proceed_to_payment()

if __name__ == "__main__":
    if result == 'Legitimate':
      proceed_to_payment()
    else:
        ask_warning_questions()
        proceed_to_payment()

